# -*- coding: utf-8 -*-
"""CSE221_Assignment_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DvNq97ugozL-fMs2aPu-PyiWR3e0CSCy

A. Count the Inversion
"""

n = int(input())
arr = input().split()
arr = [int(i) for i in arr]

def merge(a, b):
    sorted = []
    count = 0
    i = 0
    j = 0

    while i < len(a[0]) and j < len(b[0]):
        if a[0][i] <= b[0][j]:
            sorted.append(a[0][i])
            i += 1
        else:
            sorted.append(b[0][j])
            j += 1
            count += len(a[0]) - i

    while i < len(a[0]):
        sorted.append(a[0][i])
        i += 1

    while j < len(b[0]):
        sorted.append(b[0][j])
        j += 1

    return sorted, a[1] + b[1] + count

def mergeSort(arr):
    if len(arr) <= 1:
        return (arr, 0)
    else:
        mid = len(arr) // 2
        a1 = mergeSort(arr[:mid])
        a2 = mergeSort(arr[mid:])
        return merge(a1, a2)

sortedArray, inversions = mergeSort(arr)

print(inversions)
for i in range (len(sortedArray)):
    print(sortedArray[i], end = " ")

"""B. Pair Maximization"""

n = int(input())
arr = input().split()
arr = [int(i) for i in arr]

def pairMaximization(arr, i, j):

    if i == j:
        return -float('inf')

    if j - i == 1:
        return arr[i] + arr[j] ** 2

    else:
        mid = (i + j) // 2
        max_left = pairMaximization(arr, i, mid)
        max_right = pairMaximization(arr, mid + 1, j)

    max_cross = float('-inf')
    for left in range (i, mid + 1):
        for right in range (mid + 1, j + 1):
            if arr[left] + arr[right] ** 2 > max_cross:
                max_cross = arr[left] + arr[right] ** 2

    return max(max_left, max_right, max_cross)

print(pairMaximization(arr, 0, n - 1))

n = int(input())
arr = input().split()
arr = [int(i) for i in arr]

def pairMaximization(arr, i, j):

    if i == j:
        return -float('inf')

    if j - i == 1:
        return arr[i] + arr[j] ** 2

    else:
        mid = (i + j) // 2
        max_left = pairMaximization(arr, i, mid)
        max_right = pairMaximization(arr, mid + 1, j)

        max_right_for_cross = float('-inf')
        for right in range (mid + 1, j + 1):
            max_right_for_cross = max(max_right_for_cross, arr[right] ** 2)

        max_cross = float('-inf')
        for left in range (i, mid + 1):
            max_cross = max(max_cross, arr[left] + max_right_for_cross)

    return max(max_left, max_right, max_cross)

print(pairMaximization(arr, 0, n - 1))

"""C. Fast MOD Drift"""

a, b = input().split()
a, b = int(a), int(b)

result = 1
a = a % 107

while b > 0:
    if b % 2 == 1:
        result = (result * a) % 107
    a = (a ** 2) % 107
    b = b // 2

print(result)

"""D. Fast MOD Drift Revisited"""

t = int(input())

for i in range (t):
    a, n, m = input().split()
    a, n, m = int(a), int(n), int(m)

    if a != 1:
        sum = a * ((a ** n) - 1)/(a - 1)
    else:
        sum = n
    result = int(sum % m)

    print(result)

t = int(input())

for i in range (t):
    a, n, m = input().split()
    a, n, m = int(a), int(n), int(m)

    if a == 1:
        result = n % m

    else:
        m = m * (a - 1)
        result = 1
        a_temp = a
        n_temp = n
        while n_temp > 0:
            if n_temp % 2 == 1:
                result = (result * a_temp) % m
            a_temp = (a_temp * a_temp) % m
            n_temp = n_temp // 2
        sum = (a * (result - 1)) // (a - 1)
        result = sum % m

    print(result)

t = int(input())

for i in range (t):
    a, n, m = input().split()
    a, n, m = int(a), int(n), int(m)

    def fastModularExponentiation(a, b, m):
        result = 1
        a = a % m

        while b > 0:
            if b % 2 == 1:
                result = (result * a) % m
            a = (a ** 2) % m
            b = b // 2

        return result

    def recursiveSummation(a, n, m):
        if a == 1:
            return (n % m)
        mod = m * (a - 1)
        result = fastModularExponentiation(a, n, mod)
        sum = (a * (result - 1)) // (a - 1)
        result = sum % m
        return result

    print(recursiveSummation(a, n, m))

def fast_exponentiation(a, n, mod):
    result = 1
    a = a % mod
    while n > 0:
        if n % 2 == 1:
            result = (result * a) % mod
        a = (a * a) % mod
        n = n // 2
    return result

def geometric_series_sum(a, n, m):
    if a == 1:
        return n % m
    mod = m * (a - 1)
    a_n = fast_exponentiation(a, n, mod)
    S = (a * (a_n - 1)) // (a - 1)
    return S % m

T = int(input())
for i in range(T):
    input_line = input().split()
    a = int(input_line[0])
    n = int(input_line[1])
    m = int(input_line[2])
    print(geometric_series_sum(a, n, m))

"""E. Ordering Binary Tree"""

n = int(input())
arr = input().split()
arr = [int(i) for i in arr]

tree = []
start = 0
end = n - 1

def orderingTree(arr, start, end):
    if start > end:
        return []

    mid = (start + end) // 2
    tree.append(arr[mid])
    left = orderingTree(arr, start, mid - 1)
    right = orderingTree(arr, mid + 1, end)

    return tree

tree = orderingTree(arr, start, end)

for i in range (len(tree)):
    print(tree[i], end = " ")

"""F. 220 Trees"""

n = int(input())
inorder = input().split()
inorder = [int(i) for i in inorder]
preorder = input().split()
preorder = [int(i) for i in preorder]

postorder = []

def postorderTraversal(inorder, preorder):
    if not preorder:
        return []

    root = preorder[0]
    root_index = inorder.index(root)

    left_in = inorder[:root_index]
    right_in = inorder[root_index+1:]

    left_pre = preorder[1:1+len(left_in)]
    right_pre = preorder[1+len(left_in):]

    postorderTraversal(left_in, left_pre)
    postorderTraversal(right_in, right_pre)
    postorder.append(root)

    return postorder

postorder = postorderTraversal(inorder, preorder)

for i in range (len(postorder)):
    print(postorder[i], end=" ")

# Incorrect

n = int(input())
inorder = input().split()
inorder = [int(i) for i in inorder]
preorder = input().split()
preorder = [int(i) for i in preorder]

def postorder_from_traversals(inorder, preorder):
    stack = []
    postorder = []
    inorder_index = 0

    for val in preorder:
        stack.append(val)

        while stack and stack[-1] == inorder[inorder_index]:
            postorder.append(stack.pop())
            inorder_index += 1

    return postorder

postorder = postorder_from_traversals(inorder, preorder)
for i in range (len(postorder)):
    print(postorder[i], end=" ")