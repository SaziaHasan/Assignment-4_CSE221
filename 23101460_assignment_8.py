# -*- coding: utf-8 -*-
"""CSE221_Assignment_8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yN5i3rHxQxPiAB_oP9qO_anahprLg67O

A. Friendship
"""

n, k = map(int, input().split())

parent = list(range(n + 1))
size = [1] * (n + 1)

def find(u):
    if parent[u] != u:
        parent[u] = find(parent[u])
    return parent[u]

def union(u, v):
    root_u = find(u)
    root_v = find(v)
    if root_u == root_v:
        return size[root_u]
    if size[root_u] < size[root_v]:
        root_u, root_v = root_v, root_u
    parent[root_v] = root_u
    size[root_u] += size[root_v]
    return size[root_u]

for _ in range(k):
    ai, aj = map(int, input().split())
    print(union(ai, aj))

"""B. Help the King!"""

n, m = map(int, input().split())

edges = []

for _ in range(m):
    u, v, w = map(int, input().split())
    edges.append((w, u, v))

edges.sort()

parent = list(range(n + 1))
rank = [0] * (n + 1)

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x == root_y:
        return False
    if rank[root_x] < rank[root_y]:
        root_x, root_y = root_y, root_x
    parent[root_y] = root_x
    if rank[root_x] == rank[root_y]:
        rank[root_x] += 1
    return True

total_cost = 0
for w, u, v in edges:
    if union(u, v):
        total_cost += w

print(total_cost)

"""C. Again MST"""

n, m = map(int, input().split())

edges = []

for _ in range(m):
    u, v, w = map(int, input().split())
    edges.append((w, u, v))

edges.sort()

parent = list(range(n + 1))
rank = [0] * (n + 1)

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x == root_y:
        return False
    if rank[root_x] < rank[root_y]:
        root_x, root_y = root_y, root_x
    parent[root_y] = root_x
    if rank[root_x] == rank[root_y]:
        rank[root_x] += 1
    return True

mst_edges = []
total = 0
for w, u, v in edges:
    if union(u, v):
        mst_edges.append((w, u, v))
        total += w

if len(mst_edges) != n - 1:
    print(-1)
    exit()

second_total = float('inf')

for excluded_w, excluded_u, excluded_v in mst_edges:
    parent = list(range(n + 1))
    rank = [0] * (n + 1)
    current_total = 0
    count = 0
    for w, u, v in edges:
        if (w == excluded_w and u == excluded_u and v == excluded_v):
            continue
        if union(u, v):
            current_total += w
            count += 1
    if count == n - 1:
        if current_total > total:
            if current_total < second_total:
                second_total = current_total

if second_total != float('inf'):
    print(second_total)
else:
    print(-1)

from collections import defaultdict

n, m = map(int, input().split())

edges = []

for _ in range(m):
    u, v, w = map(int, input().split())
    edges.append((w, u, v))

edges.sort()

parent = list(range(n + 1))
rank = [0] * (n + 1)

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x == root_y:
        return False
    if rank[root_x] < rank[root_y]:
        root_x, root_y = root_y, root_x
    parent[root_y] = root_x
    if rank[root_x] == rank[root_y]:
        rank[root_x] += 1
    return True

mst_edges = []
total = 0
for w, u, v in edges:
    if union(u, v):
        mst_edges.append((w, u, v))
        total += w

if len(mst_edges) != n - 1:
    print(-1)
    exit()

adjList = defaultdict(list)
mst_set = set()
for w, u, v in mst_edges:
    adjList[u].append((v, w))
    adjList[v].append((u, w))
    mst_set.add((min(u, v), max(u, v), w))

max_edge = [[0] * (n+1) for _ in range(n+1)]

def dfs(u, p, path, start):
    for v, w in adjList[u]:
        if v != p:
            nMax = max(path, w)
            max_edge[start][v] = nMax
            max_edge[v][start] = nMax
            dfs(v, u, nMax, start)

for u in range(1, n+1):
    dfs(u, -1, 0, u)

second_best = float('inf')

for w, u, v in edges:
    if (min(u, v), max(u, v), w) not in mst_set:
        replace = max_edge[u][v]
        if replace < w:
            curr = total + w - replace
            if curr > total and curr < second_best:
                second_best = curr

print(second_best if second_best != float('inf') else -1)
