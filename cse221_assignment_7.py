# -*- coding: utf-8 -*-
"""CSE221_Assignment_7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c-2SsWDqn6i_0r2pwum6P29PI1N0GstY

A. Shortest Path
"""

import heapq

n, m, s, d = map(int, input().split())
u_list = list(map(int, input().split()))
v_list = list(map(int, input().split()))
w_list = list(map(int, input().split()))

adjList = [[] for _ in range(n + 1)]
for i in range(m):
    u = u_list[i]
    v = v_list[i]
    w = w_list[i]
    adjList[u].append((v, w))

dist = [float('inf')] * (n + 1)
prev = [-1] * (n + 1)
dist[s] = 0
pq = [(0, s)]

while pq:
    curr_dist, u = heapq.heappop(pq)
    if curr_dist > dist[u]:
        continue
    for v, w in adjList[u]:
        if dist[v] > dist[u] + w:
            dist[v] = dist[u] + w
            prev[v] = u
            heapq.heappush(pq, (dist[v], v))

if dist[d] == float('inf'):
    print(-1)
else:
    print(dist[d])
    path = []
    node = d
    while node != -1:
        path.append(node)
        node = prev[node]
    print(" ".join(map(str, reversed(path))))

"""B. Where to Meet?"""

import heapq

INF = float('inf')

n, m, s, t = map(int, input().split())
adjList = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v, w = map(int, input().split())
    adjList[u].append((v, w))

def dijkstra(start):
    dist = [INF] * (n + 1)
    dist[start] = 0
    pq = [(0, start)]

    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        for v, w in adjList[u]:
            if dist[v] > d + w:
                dist[v] = d + w
                heapq.heappush(pq, (dist[v], v))
    return dist

dist_s = dijkstra(s)
dist_t = dijkstra(t)

min_time = INF
meeting_node = -1

for i in range(1, n + 1):
    time_to_meet = max(dist_s[i], dist_t[i])
    if time_to_meet < min_time:
        min_time = time_to_meet
        meeting_node = i
    elif time_to_meet == min_time and i < meeting_node:
        meeting_node = i

if min_time == INF:
    print(-1)
else:
    print(f"{min_time} {meeting_node}")

"""C. Minimize the Danger"""

import heapq

INF = float('inf')

n, m = map(int, input().split())
adjList = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v, w = map(int, input().split())
    adjList[u].append((v, w))
    adjList[v].append((u, w))

danger = [INF] * (n + 1)
danger[1] = 0

pq = [(0, 1)]

while pq:
    curr_danger, u = heapq.heappop(pq)
    if curr_danger > danger[u]:
        continue
    for v, w in adjList[u]:
        path_danger = max(curr_danger, w)
        if path_danger < danger[v]:
            danger[v] = path_danger
            heapq.heappush(pq, (path_danger, v))

res = []
for i in range(1, n + 1):
    res.append(str(danger[i] if danger[i] != INF else -1))

print(" ".join(res))

"""D. Beautiful Path"""

import heapq

INF = float('inf')

n, m, s, d = map(int, input().split())
weights = list(map(int, input().split()))

adjList = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v = map(int, input().split())
    adjList[u].append(v)

dist = [INF] * (n + 1)
dist[s] = weights[s - 1]

pq = [(dist[s], s)]

while pq:
    cost, u = heapq.heappop(pq)
    if cost > dist[u]:
        continue
    for v in adjList[u]:
        new_cost = cost + weights[v - 1]
        if new_cost < dist[v]:
            dist[v] = new_cost
            heapq.heappush(pq, (new_cost, v))

print(dist[d] if dist[d] != INF else -1)

"""E. Parity Edges"""

import heapq

INF = float('inf')

n, m = map(int, input().split())
u = list(map(int, input().split()))
v = list(map(int, input().split()))
w = list(map(int, input().split()))

adjList = [[] for _ in range(n + 1)]
for i in range(m):
    adjList[u[i]].append((v[i], w[i]))

dist = [[INF] * 2 for _ in range(n + 1)]
pq = []

for i, weight in adjList[1]:
    parity = weight % 2
    dist[i][parity] = weight
    heapq.heappush(pq, (weight, i, parity))

while pq:
    cost, u, last_parity = heapq.heappop(pq)
    if dist[u][last_parity] < cost:
        continue
    for n_v, n_w in adjList[u]:
        new_parity = n_w % 2
        if new_parity != last_parity:
            new_cost = cost + n_w
            if new_cost < dist[n_v][new_parity]:
                dist[n_v][new_parity] = new_cost
                heapq.heappush(pq, (new_cost, n_v, new_parity))

res = min(dist[n])
print(res if res != INF else -1)

"""F. Shortest Path Revisited"""

import heapq

INF = float('inf')

n, m, s, d = map(int, input().split())

adjList = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v, w = map(int, input().split())
    adjList[u].append((v, w))
    adjList[v].append((u, w))

dist1 = [INF] * (n + 1)
dist2 = [INF] * (n + 1)
dist1[s] = 0

pq = [(0, s)]

while pq:
    cost, u = heapq.heappop(pq)

    for v, w in adjList[u]:
        new_cost = cost + w

        if new_cost < dist1[v]:
            dist2[v] = dist1[v]
            dist1[v] = new_cost
            heapq.heappush(pq, (new_cost, v))
        elif dist1[v] < new_cost < dist2[v]:
            dist2[v] = new_cost
            heapq.heappush(pq, (new_cost, v))

print(dist2[d] if dist2[d] != INF else -1)