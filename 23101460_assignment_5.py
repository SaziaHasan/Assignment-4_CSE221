# -*- coding: utf-8 -*-
"""CSE221_Assignment_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H5IlEm4XqM5wWttFLn36Ulm0bv2TOtVa

A. Can you Traverse-1?
"""

from collections import deque

n, m = input().split()
n, m = int(n), int(m)

adjList = []
for i in range (n + 1):
    adjList.append([])

for i in range (m):
    u, v = input().split()
    u, v = int(u), int(v)
    adjList[u].append(v)
    adjList[v].append(u)

color = [0] * (n + 1)
Q = deque()

color[1] = 1
Q.append(1)

result = []

while Q:
    u = Q.popleft()
    result.append(str(u))
    for v in adjList[u]:
        if color[v] == 0:
            color[v] = 1
            Q.append(v)

print(' '.join(result))

"""B. Can you Traverse-2?"""

import sys
sys.setrecursionlimit(2 * 100000 + 5)

n, m = input().split()
n, m = int(n), int(m)

uList = input().split()
uList = [int(i) for i in uList]

vList = input().split()
vList = [int(i) for i in vList]

adjList = [[] for _ in range(n + 1)]
for i in range (m):
    u = uList[i]
    v = vList[i]
    adjList[u].append(v)
    adjList[v].append(u)

visited = [0] * (n + 1)
result = []

stack = [(1, False)]

while stack:
    node, processed = stack.pop()
    if processed:
        continue
    if visited[node]:
        continue
    visited[node] = 1
    result.append(str(node))
    for adj in reversed(adjList[node]):
        if not visited[adj]:
            stack.append((adj, False))

print(' '.join(result))

import sys
sys.setrecursionlimit(2 * 100000 + 5)

n, m = map(int, input().split())
uList = list(map(int, input().split()))
vList = list(map(int, input().split()))

adjList = [[] for _ in range(n + 1)]
for i in range(m):
    u = uList[i]
    v = vList[i]
    adjList[u].append(v)
    adjList[v].append(u)

for adj in adjList:
    adj.sort()

visited = [0] * (n + 1)
result = []

def colourInitializing():
    for i in range(1, n + 1):
        visited[i] = 0

def DFS(u):
    visited[u] = 1
    result.append(str(u))
    for v in adjList[u]:
        if visited[v] == 0:
            DFS(v)

colourInitializing()
DFS(1)

print(' '.join(result))

"""C. Lightning McQueen"""

from collections import deque

n, m, s, d = input().split()
n, m, s, d = int(n), int(m), int(s), int(d)

u = input().split()
uList = [int(i) for i in u]

v = input().split()
vList = [int(i) for i in v]

adjList = [[] for _ in range (n + 1)]
for i in range (m):
    u = uList[i]
    v = vList[i]
    adjList[u].append(v)
    adjList[v].append(u)

for i in range (1, n + 1):
    adjList[i].sort()

visited = [False] * (n + 1)
parent = [0] * (n + 1)
dist = [-1] * (n + 1)

s, d = int(s), int(d)
queue = deque()
queue.append(s)
visited[s] = True
dist[s] = 0

while queue:
    curr = queue.popleft()
    for adj in adjList[curr]:
        if not visited[adj]:
            visited[adj] = True
            parent[adj] = curr
            dist[adj] = dist[curr] + 1
            queue.append(adj)

if not visited[d]:
    print(-1)
else:
    path = []
    current = d
    while current != 0:
        path.append(current)
        current = parent[current]
    path.reverse()
    print(dist[d])
    print(' '.join(map(str, path)))

"""D. Through the Jungle"""

from collections import deque

n, m, s, d, k = input().split()
n, m, s, d, k = int(n), int(m), int(s), int(d), int(k)

adjList = [[] for _ in range (n+1)]
for i in range (m):
    u, v = input().split()
    u, v = int(u), int(v)
    adjList[u].append(v)

def bfs(start, end):
    parent = [-1] * (n + 1)
    visited = [False] * (n + 1)
    q = deque()
    q.append(start)
    visited[start] = True
    found = False
    while q:
        node = q.popleft()
        if node == end:
            found = True
            break
        for neighbor in adjList[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                q.append(neighbor)
    if not found:
        return None
    path = []
    current = end
    while current != -1:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path

path_SK = bfs(s, k)
path_KD = bfs(k, d)

if path_SK is None or path_KD is None:
    print(-1)
else:
    total_path = path_SK[:-1] + path_KD
    print(len(total_path) - 1)
    print(' '.join(map(str, total_path)))

"""E. Cycle Detection"""

n, m = input().split()
n, m = int(n), int(m)

adjList = [[] for _ in range(n + 1)]

for i in range (m):
    u, v = input().split()
    u, v = int(u), int(v)
    adjList[u].append(v)

visited = [0] * (n + 1)
has_cycle = False

def dfs(node):
    global has_cycle
    visited[node] = 1
    for neighbor in adjList[node]:
        if visited[neighbor] == 0:
            dfs(neighbor)
        elif visited[neighbor] == 1:
            has_cycle = True
    visited[node] = 2

for i in range(1, n + 1):
    if visited[i] == 0:
        dfs(i)

print("YES" if has_cycle else "NO")

n, m = input().split()
n, m = int(n), int(m)

adjList = [[] for _ in range(n + 1)]

for i in range(m):
    u, v = input().split()
    u, v = int(u), int(v)
    adjList[u].append(v)

visited = [0] * (n + 1)
has_cycle = [False]

def dfs(node):
    visited[node] = 1
    for neighbor in adjList[node]:
        if visited[neighbor] == 0:
            dfs(neighbor)
        elif visited[neighbor] == 1:
            has_cycle[0] = True
    visited[node] = 2

for i in range(1, n + 1):
    if visited[i] == 0:
        dfs(i)

print("YES" if has_cycle[0] else "NO")

import sys
sys.setrecursionlimit(2 * 100000 + 5)

n, m = input().split()
n, m = int(n), int(m)

adjList = [[] for _ in range(n + 1)]
for i in range(m):
    u, v = input().split()
    u, v = int(u), int(v)
    adjList[u].append(v)

visited = [False] * (n + 1)
st = [False] * (n + 1)

def is_cyclic(node):
    visited[node] = True
    st[node] = True
    for adj in adjList[node]:
        if not visited[adj]:
            if is_cyclic(adj):
                return True
        elif st[adj]:
            return True
    st[node] = False
    return False

cycle_found = False
for node in range(1, n + 1):
    if not visited[node]:
        if is_cyclic(node):
            print("YES")
            cycle_found = True
            break

if not cycle_found:
    print("NO")

n, m = input().split()
n, m = int(n), int(m)

adjList = [[] for _ in range(n + 1)]

for i in range(m):
    u, v = input().split()
    u, v = int(u), int(v)
    adjList[u].append(v)

visited = [0] * (n + 1)
has_cycle = False

for start in range(1, n + 1):
    if visited[start] == 0:
        stack = [(start, 0)]
        path = []
        while stack:
            node, idx = stack[-1]
            if visited[node] == 0:
                visited[node] = 1
                path.append(node)
            adj = adjList[node]
            if idx < len(adj):
                adj = adj[idx]
                stack[-1] = (node, idx + 1)
                if visited[adj] == 0:
                    stack.append((adj, 0))
                elif visited[adj] == 1:
                    has_cycle = True
                    break
            else:
                visited[node] = 2
                stack.pop()
        if has_cycle:
            break

if has_cycle:
    print("YES")
else:
    print("NO")

import sys
sys.setrecursionlimit(2*100000+5)

n, m = map(int, input().split())

adjList = [[] for i in range(n + 1)]
for i in range(m):
    u, v = map(int, input().split())
    adjList[u].append(v)

def has_cycle(adjList, n):
    color = [0] * (n + 1)

    def dfs(node):
        if color[node] == 1:
            return True

        if color[node] == 2:
            return False

        color[node] = 1

        for adj in adjList[node]:
            if dfs(adj):
                return True

        color[node] = 2
        return False

    for node in range(1, n + 1):
        if color[node] == 0:
            if dfs(node):
                return True

    return False

if has_cycle(adjList, n):
    print("YES")
else:
    print("NO")

import sys
sys.setrecursionlimit(2 * 10**5 + 10)

n, m = input().split()
n, m = int(n), int(m)
adj_list = []
for _ in range (n+1):
    adj_list.append([])

for _ in range(m):
    u, v = input().split()
    u, v = int(u), int(v)
    adj_list[u].append(v)

visited = [False]*(n+1)
stack = [False]*(n+1)
has_cycle = [False]

def DFS(vertex):
    visited[vertex] = True
    stack[vertex] = True
    for neighbor in adj_list[vertex]:
        if not visited[neighbor]:
            DFS(neighbor)
            if has_cycle[0]:
                return
        elif stack[neighbor]:
            has_cycle[0] = True
            return

    stack[vertex] = False

for i in range(1,n+1):
    if not visited[i]:
        DFS(i)
        if has_cycle[0]:
            break

if has_cycle[0]:
    print("YES")
else:
    print("NO")

"""F. Diamonds under W"""

from collections import deque

r, h = input().split()
r, h = int(r), int(h)

grid = []
for i in range(r):
    grid.append(list(input()))

visited = [[False] * h for _ in range(r)]
max_diamonds = 0

directions = [(-1,0), (1,0), (0,-1), (0,1)]

for i in range(r):
    for j in range(h):
        if not visited[i][j] and grid[i][j] != '#':
            queue = deque()
            queue.append((i, j))
            visited[i][j] = True
            diamonds = 0

            while queue:
                x, y = queue.popleft()
                if grid[x][y] == 'D':
                    diamonds += 1
                for dx, dy in directions:
                    new_x, new_y = x + dx, y + dy
                    if 0 <= new_x < r and 0 <= new_y < h:
                        if not visited[new_x][new_y] and grid[new_x][new_y] != '#':
                            visited[new_x][new_y] = True
                            queue.append((new_x, new_y))

            max_diamonds = max(max_diamonds, diamonds)

print(max_diamonds)
